<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NOVA SYSTEMS | Helical Drive</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto+Mono:wght@300;500&display=swap"
        rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --glow: #ffaa00;
            --glass: rgba(255, 255, 255, 0.05);
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #030305;
            font-family: 'Orbitron', sans-serif;
            color: white;
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #hud {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border-top: 2px solid var(--glow);
            padding: 20px;
            font-family: 'Roboto Mono', monospace;
            font-size: 11px;
            pointer-events: none;
            backdrop-filter: blur(8px);
            z-index: 10;
        }

        .telemetry-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            color: #ccc;
        }

        .t-label {
            color: var(--glow);
            font-weight: bold;
        }

        .glass-card {
            position: absolute;
            top: 50%;
            right: 10%;
            /* Moved to right to balance composition */
            transform: translateY(-50%);
            background: var(--glass);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 40px;
            text-align: left;
            z-index: 5;
            width: 320px;
            border-radius: 8px;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        h1 {
            margin: 0 0 20px 0;
            font-size: 2rem;
            letter-spacing: 5px;
            background: linear-gradient(90deg, #fff, #aaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        p {
            font-family: 'Roboto Mono';
            font-size: 0.8rem;
            line-height: 1.5;
            margin-bottom: 30px;
            color: #aaa;
        }

        .input-group {
            margin-bottom: 15px;
            position: relative;
        }

        input {
            width: 100%;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            color: white;
            font-family: 'Roboto Mono';
            outline: none;
            box-sizing: border-box;
            transition: 0.3s;
        }

        input:focus {
            border-color: var(--glow);
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.2);
        }

        button {
            width: 100%;
            padding: 15px;
            background: var(--glow);
            border: none;
            color: #000;
            font-weight: 700;
            font-family: 'Orbitron';
            cursor: pointer;
            letter-spacing: 2px;
            transition: 0.3s;
            margin-top: 10px;
        }

        button:hover {
            background: white;
            box-shadow: 0 0 25px white;
        }

        /* Loading Overlay */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 1s;
        }
    </style>
</head>

<body>

    <div id="loader">
        <h1>INITIALIZING VORTEX...</h1>
    </div>

    <div id="hud">
        <div class="telemetry-row"><span class="t-label">VELOCITY</span> <span>220 KM/S</span></div>
        <div class="telemetry-row"><span class="t-label">VECTOR</span> <span>GALACTIC CENTER</span></div>
        <div class="telemetry-row"><span class="t-label">TRAJECTORY</span> <span>HELICAL/STABLE</span></div>
        <br>
        <div id="planet-list"></div>
    </div>

    <!-- <div class="glass-card">
        <h1>NOVA</h1>
        <p>SECURE ACCESS TERMINAL<br>VORTEX PROTOCOL: ACTIVE</p>
        <div class="input-group">
            <input type="text" placeholder="CMD_ACCESS_KEY">
        </div>
        <div class="input-group">
            <input type="password" placeholder="ENCRYPTION_TOKEN">
        </div>
        <button>LAUNCH</button>
    </div> -->
    <div class="glass-card">
        <h1>Abhishek</h1>
        <p>8750892993<br>Aj956087@gmail.com</p>
    </div>
    <script>
        // CONFIGURATION
        const PLANETS = [
            { name: "MERCURY", color: 0xA5A5A5, size: 0.8, dist: 14, speed: 0.08 },
            { name: "VENUS", color: 0xE3BB76, size: 1.5, dist: 22, speed: 0.06 },
            { name: "EARTH", color: 0x2271B3, size: 1.6, dist: 30, speed: 0.05 },
            { name: "MARS", color: 0xE27B58, size: 1.2, dist: 38, speed: 0.04 },
            { name: "JUPITER", color: 0xD39C7E, size: 4.5, dist: 55, speed: 0.02 },
            { name: "SATURN", color: 0xC5AB6E, size: 3.8, dist: 75, speed: 0.015 },
            { name: "URANUS", color: 0xB5E3E3, size: 2.5, dist: 90, speed: 0.01 },
            { name: "NEPTUNE", color: 0x4B70DD, size: 2.4, dist: 105, speed: 0.008 }
        ];

        const SCENE_SPEED = 2.0; // Speed of the forward travel (stars/trails moving left)

        let scene, camera, renderer;
        let sun;
        let planetSystems = []; // Stores mesh + trail logic
        let stars;

        function init() {
            scene = new THREE.Scene();
            // Camera position: Side view to see the "Helix" clearly
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 40, 180);
            camera.lookAt(20, 0, 0); // Look slightly ahead of the Sun

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // 1. THE SUN (Leading the way)
            const sunGeo = new THREE.SphereGeometry(10, 64, 64);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            sun = new THREE.Mesh(sunGeo, sunMat);
            sun.position.set(60, 0, 0); // Positioned to the right
            scene.add(sun);

            // Sun Glow
            const sunLight = new THREE.PointLight(0xffaa00, 3, 300);
            sunLight.position.set(60, 0, 0);
            scene.add(sunLight);

            // Global Ambient Light
            scene.add(new THREE.AmbientLight(0x404040, 1));

            // 2. PLANETS & TRAILS
            const list = document.getElementById('planet-list');

            PLANETS.forEach(p => {
                // Planet Group (anchored relative to Sun's X, but orbiting)
                const group = new THREE.Group();
                scene.add(group);

                // The Planet Mesh
                const mesh = new THREE.Mesh(
                    new THREE.SphereGeometry(p.size, 32, 32),
                    new THREE.MeshStandardMaterial({ color: p.color, roughness: 0.6, metalness: 0.1 })
                );
                group.add(mesh);

                // TRAIL SETUP
                // We use a BufferGeometry that we update every frame
                const trailLength = 150; // How long the trail is
                const trailGeo = new THREE.BufferGeometry();
                const positions = new Float32Array(trailLength * 3);
                trailGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                // Trail Material (fades out)
                const trailMat = new THREE.LineBasicMaterial({
                    color: p.color,
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending
                });
                const trailLine = new THREE.Line(trailGeo, trailMat);
                scene.add(trailLine); // Add directly to scene, not group

                planetSystems.push({
                    mesh: mesh,
                    trail: trailLine,
                    trailPositions: [], // Array to store Vector3s
                    data: p,
                    angle: Math.random() * Math.PI * 2
                });

                // HUD Update
                list.innerHTML += `<div class="telemetry-row" style="color:${'#' + p.color.toString(16)}">${p.name} <span style="color:#666">TRACKING</span></div>`;
            });

            // 3. MOVING STARFIELD
            const starCount = 3000;
            const starGeo = new THREE.BufferGeometry();
            const starPos = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount * 3; i++) {
                starPos[i] = (Math.random() - 0.5) * 600;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.8, transparent: true, opacity: 0.8 });
            stars = new THREE.Points(starGeo, starMat);
            scene.add(stars);

            // Remove Loader
            setTimeout(() => {
                document.getElementById('loader').style.opacity = '0';
                setTimeout(() => document.getElementById('loader').remove(), 1000);
            }, 500);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);

            // 1. STARFIELD MOVEMENT (Right to Left)
            // Simulates the camera/sun moving Right
            const positions = stars.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i] -= SCENE_SPEED; // Move X backward

                // Reset stars that go off screen to the right
                if (positions[i] < -300) {
                    positions[i] = 300;
                }
            }
            stars.geometry.attributes.position.needsUpdate = true;

            // 2. PLANET ORBITS & TRAIL LOGIC
            planetSystems.forEach(sys => {
                // A. Update Planet Position
                // Orbit Center is the Sun's X (60). 
                // We keep the Sun "static" in X for the camera, but the trails move back.
                sys.angle += sys.data.speed;

                const sunX = 60;
                // X stays relative to Sun, Y/Z do the circle
                const currentX = sunX;
                const currentY = Math.cos(sys.angle) * sys.data.dist;
                const currentZ = Math.sin(sys.angle) * sys.data.dist;

                sys.mesh.position.set(currentX, currentY, currentZ);
                sys.mesh.rotation.y += 0.02;

                // B. Manage Trails (The Helical Effect)
                // 1. Shift all existing trail points backwards (Right to Left flow)
                for (let i = 0; i < sys.trailPositions.length; i++) {
                    sys.trailPositions[i].x -= SCENE_SPEED;
                }

                // 2. Add new point at current planet position
                sys.trailPositions.unshift(new THREE.Vector3(currentX, currentY, currentZ));

                // 3. Limit trail length
                if (sys.trailPositions.length > 200) {
                    sys.trailPositions.pop();
                }

                // 4. Update Line Geometry
                const positions = sys.trail.geometry.attributes.position.array;
                for (let i = 0; i < sys.trailPositions.length; i++) {
                    positions[i * 3] = sys.trailPositions[i].x;
                    positions[i * 3 + 1] = sys.trailPositions[i].y;
                    positions[i * 3 + 2] = sys.trailPositions[i].z;
                }
                sys.trail.geometry.setDrawRange(0, sys.trailPositions.length);
                sys.trail.geometry.attributes.position.needsUpdate = true;
            });

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>

</html>